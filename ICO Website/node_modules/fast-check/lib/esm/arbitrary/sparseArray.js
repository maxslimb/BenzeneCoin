import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';
import { integer } from './integer.js';
import { nat } from './nat.js';
import { set } from './set.js';
import { tuple } from './tuple.js';
import { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';
function extractMaxIndex(indexesAndValues) {
    let maxIndex = -1;
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);
    }
    return maxIndex;
}
function arrayFromItems(length, indexesAndValues) {
    const array = Array(length);
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        const it = indexesAndValues[index];
        if (it[0] < length)
            array[it[0]] = it[1];
    }
    return array;
}
export function sparseArray(arb, constraints = {}) {
    const { minNumElements = 0, maxNumElements = maxLengthFromMinLength(minNumElements), maxLength = Math.min(maxLengthFromMinLength(maxNumElements), 4294967295), noTrailingHole, } = constraints;
    if (minNumElements > maxLength) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
    }
    if (minNumElements > maxNumElements) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
    }
    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);
    const maxIndexAuthorized = Math.max(maxLength - 1, 0);
    const sparseArrayNoTrailingHole = convertFromNext(convertToNext(set(tuple(nat(maxIndexAuthorized), arb), {
        minLength: minNumElements,
        maxLength: resultedMaxNumElements,
        compare: { selector: (item) => item[0] },
    })).map((items) => {
        const lastIndex = extractMaxIndex(items);
        return arrayFromItems(lastIndex + 1, items);
    }, (value) => {
        if (!Array.isArray(value)) {
            throw new Error('Not supported entry type');
        }
        return Object.entries(value).map((entry) => [Number(entry[0]), entry[1]]);
    }));
    if (noTrailingHole || maxLength === minNumElements) {
        return sparseArrayNoTrailingHole;
    }
    return convertFromNext(convertToNext(tuple(sparseArrayNoTrailingHole, integer({ min: minNumElements, max: maxLength }))).map((data) => {
        const sparse = data[0];
        const targetLength = data[1];
        if (sparse.length >= targetLength) {
            return sparse;
        }
        const longerSparse = sparse.slice();
        longerSparse.length = targetLength;
        return longerSparse;
    }, (value) => {
        if (!Array.isArray(value)) {
            throw new Error('Not supported entry type');
        }
        return [value, value.length];
    }));
}
